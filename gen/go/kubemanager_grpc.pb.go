// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: kubemanager.proto

package kubemanager

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	KubeManagerService_CreateCluster_FullMethodName        = "/kubemanager.KubeManagerService/CreateCluster"
	KubeManagerService_DeployApp_FullMethodName            = "/kubemanager.KubeManagerService/DeployApp"
	KubeManagerService_ScaleCluster_FullMethodName         = "/kubemanager.KubeManagerService/ScaleCluster"
	KubeManagerService_DeleteCluster_FullMethodName        = "/kubemanager.KubeManagerService/DeleteCluster"
	KubeManagerService_GetClusterStatus_FullMethodName     = "/kubemanager.KubeManagerService/GetClusterStatus"
	KubeManagerService_ListClustersByTenant_FullMethodName = "/kubemanager.KubeManagerService/ListClustersByTenant"
	KubeManagerService_GetClusterLogs_FullMethodName       = "/kubemanager.KubeManagerService/GetClusterLogs"
	KubeManagerService_RestartComponent_FullMethodName     = "/kubemanager.KubeManagerService/RestartComponent"
	KubeManagerService_ExportClusterConfig_FullMethodName  = "/kubemanager.KubeManagerService/ExportClusterConfig"
	KubeManagerService_ApplyClusterConfig_FullMethodName   = "/kubemanager.KubeManagerService/ApplyClusterConfig"
	KubeManagerService_GetClusterOperations_FullMethodName = "/kubemanager.KubeManagerService/GetClusterOperations"
	KubeManagerService_ListClusterUsers_FullMethodName     = "/kubemanager.KubeManagerService/ListClusterUsers"
	KubeManagerService_AddClusterUser_FullMethodName       = "/kubemanager.KubeManagerService/AddClusterUser"
	KubeManagerService_UpgradeCluster_FullMethodName       = "/kubemanager.KubeManagerService/UpgradeCluster"
	KubeManagerService_GetNodeHealth_FullMethodName        = "/kubemanager.KubeManagerService/GetNodeHealth"
)

// KubeManagerServiceClient is the client API for KubeManagerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ───────────────────────────────
// SERVICE
// ───────────────────────────────
type KubeManagerServiceClient interface {
	// Provisionner un cluster
	CreateCluster(ctx context.Context, in *CreateClusterRequest, opts ...grpc.CallOption) (*OperationResponse, error)
	// Déployer une application (ex: Helm Chart)
	DeployApp(ctx context.Context, in *DeployAppRequest, opts ...grpc.CallOption) (*OperationResponse, error)
	// Ajouter un nœud au cluster
	ScaleCluster(ctx context.Context, in *ScaleClusterRequest, opts ...grpc.CallOption) (*OperationResponse, error)
	// Supprimer un cluster
	DeleteCluster(ctx context.Context, in *ClusterIDRequest, opts ...grpc.CallOption) (*OperationResponse, error)
	// Récupérer l'état d’un cluster
	GetClusterStatus(ctx context.Context, in *ClusterIDRequest, opts ...grpc.CallOption) (*ClusterStatusResponse, error)
	// Lister les clusters par tenant
	ListClustersByTenant(ctx context.Context, in *TenantRequest, opts ...grpc.CallOption) (*ClusterListResponse, error)
	// Logs ou historique
	GetClusterLogs(ctx context.Context, in *ClusterIDRequest, opts ...grpc.CallOption) (*ClusterLogResponse, error)
	// Redémarrage d'un nœud ou d'un composant
	RestartComponent(ctx context.Context, in *RestartComponentRequest, opts ...grpc.CallOption) (*OperationResponse, error)
	// Exporter une configuration kubeconfig ou helm values
	ExportClusterConfig(ctx context.Context, in *ClusterIDRequest, opts ...grpc.CallOption) (*ClusterConfigResponse, error)
	// Appliquer une configuration cluster (kubeadm, etc.)
	ApplyClusterConfig(ctx context.Context, in *ApplyClusterConfigRequest, opts ...grpc.CallOption) (*OperationResponse, error)
	GetClusterOperations(ctx context.Context, in *ClusterIDRequest, opts ...grpc.CallOption) (*ClusterOperationsResponse, error)
	// Lister les utilisateurs du cluster
	ListClusterUsers(ctx context.Context, in *ClusterIDRequest, opts ...grpc.CallOption) (*ClusterUsersResponse, error)
	// Ajouter un utilisateur (avec rôle)
	AddClusterUser(ctx context.Context, in *AddClusterUserRequest, opts ...grpc.CallOption) (*OperationResponse, error)
	UpgradeCluster(ctx context.Context, in *UpgradeClusterRequest, opts ...grpc.CallOption) (*OperationResponse, error)
	GetNodeHealth(ctx context.Context, in *NodeHealthRequest, opts ...grpc.CallOption) (*NodeHealthResponse, error)
}

type kubeManagerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewKubeManagerServiceClient(cc grpc.ClientConnInterface) KubeManagerServiceClient {
	return &kubeManagerServiceClient{cc}
}

func (c *kubeManagerServiceClient) CreateCluster(ctx context.Context, in *CreateClusterRequest, opts ...grpc.CallOption) (*OperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OperationResponse)
	err := c.cc.Invoke(ctx, KubeManagerService_CreateCluster_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubeManagerServiceClient) DeployApp(ctx context.Context, in *DeployAppRequest, opts ...grpc.CallOption) (*OperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OperationResponse)
	err := c.cc.Invoke(ctx, KubeManagerService_DeployApp_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubeManagerServiceClient) ScaleCluster(ctx context.Context, in *ScaleClusterRequest, opts ...grpc.CallOption) (*OperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OperationResponse)
	err := c.cc.Invoke(ctx, KubeManagerService_ScaleCluster_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubeManagerServiceClient) DeleteCluster(ctx context.Context, in *ClusterIDRequest, opts ...grpc.CallOption) (*OperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OperationResponse)
	err := c.cc.Invoke(ctx, KubeManagerService_DeleteCluster_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubeManagerServiceClient) GetClusterStatus(ctx context.Context, in *ClusterIDRequest, opts ...grpc.CallOption) (*ClusterStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClusterStatusResponse)
	err := c.cc.Invoke(ctx, KubeManagerService_GetClusterStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubeManagerServiceClient) ListClustersByTenant(ctx context.Context, in *TenantRequest, opts ...grpc.CallOption) (*ClusterListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClusterListResponse)
	err := c.cc.Invoke(ctx, KubeManagerService_ListClustersByTenant_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubeManagerServiceClient) GetClusterLogs(ctx context.Context, in *ClusterIDRequest, opts ...grpc.CallOption) (*ClusterLogResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClusterLogResponse)
	err := c.cc.Invoke(ctx, KubeManagerService_GetClusterLogs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubeManagerServiceClient) RestartComponent(ctx context.Context, in *RestartComponentRequest, opts ...grpc.CallOption) (*OperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OperationResponse)
	err := c.cc.Invoke(ctx, KubeManagerService_RestartComponent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubeManagerServiceClient) ExportClusterConfig(ctx context.Context, in *ClusterIDRequest, opts ...grpc.CallOption) (*ClusterConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClusterConfigResponse)
	err := c.cc.Invoke(ctx, KubeManagerService_ExportClusterConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubeManagerServiceClient) ApplyClusterConfig(ctx context.Context, in *ApplyClusterConfigRequest, opts ...grpc.CallOption) (*OperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OperationResponse)
	err := c.cc.Invoke(ctx, KubeManagerService_ApplyClusterConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubeManagerServiceClient) GetClusterOperations(ctx context.Context, in *ClusterIDRequest, opts ...grpc.CallOption) (*ClusterOperationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClusterOperationsResponse)
	err := c.cc.Invoke(ctx, KubeManagerService_GetClusterOperations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubeManagerServiceClient) ListClusterUsers(ctx context.Context, in *ClusterIDRequest, opts ...grpc.CallOption) (*ClusterUsersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClusterUsersResponse)
	err := c.cc.Invoke(ctx, KubeManagerService_ListClusterUsers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubeManagerServiceClient) AddClusterUser(ctx context.Context, in *AddClusterUserRequest, opts ...grpc.CallOption) (*OperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OperationResponse)
	err := c.cc.Invoke(ctx, KubeManagerService_AddClusterUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubeManagerServiceClient) UpgradeCluster(ctx context.Context, in *UpgradeClusterRequest, opts ...grpc.CallOption) (*OperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OperationResponse)
	err := c.cc.Invoke(ctx, KubeManagerService_UpgradeCluster_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubeManagerServiceClient) GetNodeHealth(ctx context.Context, in *NodeHealthRequest, opts ...grpc.CallOption) (*NodeHealthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NodeHealthResponse)
	err := c.cc.Invoke(ctx, KubeManagerService_GetNodeHealth_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KubeManagerServiceServer is the server API for KubeManagerService service.
// All implementations must embed UnimplementedKubeManagerServiceServer
// for forward compatibility.
//
// ───────────────────────────────
// SERVICE
// ───────────────────────────────
type KubeManagerServiceServer interface {
	// Provisionner un cluster
	CreateCluster(context.Context, *CreateClusterRequest) (*OperationResponse, error)
	// Déployer une application (ex: Helm Chart)
	DeployApp(context.Context, *DeployAppRequest) (*OperationResponse, error)
	// Ajouter un nœud au cluster
	ScaleCluster(context.Context, *ScaleClusterRequest) (*OperationResponse, error)
	// Supprimer un cluster
	DeleteCluster(context.Context, *ClusterIDRequest) (*OperationResponse, error)
	// Récupérer l'état d’un cluster
	GetClusterStatus(context.Context, *ClusterIDRequest) (*ClusterStatusResponse, error)
	// Lister les clusters par tenant
	ListClustersByTenant(context.Context, *TenantRequest) (*ClusterListResponse, error)
	// Logs ou historique
	GetClusterLogs(context.Context, *ClusterIDRequest) (*ClusterLogResponse, error)
	// Redémarrage d'un nœud ou d'un composant
	RestartComponent(context.Context, *RestartComponentRequest) (*OperationResponse, error)
	// Exporter une configuration kubeconfig ou helm values
	ExportClusterConfig(context.Context, *ClusterIDRequest) (*ClusterConfigResponse, error)
	// Appliquer une configuration cluster (kubeadm, etc.)
	ApplyClusterConfig(context.Context, *ApplyClusterConfigRequest) (*OperationResponse, error)
	GetClusterOperations(context.Context, *ClusterIDRequest) (*ClusterOperationsResponse, error)
	// Lister les utilisateurs du cluster
	ListClusterUsers(context.Context, *ClusterIDRequest) (*ClusterUsersResponse, error)
	// Ajouter un utilisateur (avec rôle)
	AddClusterUser(context.Context, *AddClusterUserRequest) (*OperationResponse, error)
	UpgradeCluster(context.Context, *UpgradeClusterRequest) (*OperationResponse, error)
	GetNodeHealth(context.Context, *NodeHealthRequest) (*NodeHealthResponse, error)
	mustEmbedUnimplementedKubeManagerServiceServer()
}

// UnimplementedKubeManagerServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedKubeManagerServiceServer struct{}

func (UnimplementedKubeManagerServiceServer) CreateCluster(context.Context, *CreateClusterRequest) (*OperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCluster not implemented")
}
func (UnimplementedKubeManagerServiceServer) DeployApp(context.Context, *DeployAppRequest) (*OperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeployApp not implemented")
}
func (UnimplementedKubeManagerServiceServer) ScaleCluster(context.Context, *ScaleClusterRequest) (*OperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ScaleCluster not implemented")
}
func (UnimplementedKubeManagerServiceServer) DeleteCluster(context.Context, *ClusterIDRequest) (*OperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCluster not implemented")
}
func (UnimplementedKubeManagerServiceServer) GetClusterStatus(context.Context, *ClusterIDRequest) (*ClusterStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterStatus not implemented")
}
func (UnimplementedKubeManagerServiceServer) ListClustersByTenant(context.Context, *TenantRequest) (*ClusterListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListClustersByTenant not implemented")
}
func (UnimplementedKubeManagerServiceServer) GetClusterLogs(context.Context, *ClusterIDRequest) (*ClusterLogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterLogs not implemented")
}
func (UnimplementedKubeManagerServiceServer) RestartComponent(context.Context, *RestartComponentRequest) (*OperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RestartComponent not implemented")
}
func (UnimplementedKubeManagerServiceServer) ExportClusterConfig(context.Context, *ClusterIDRequest) (*ClusterConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExportClusterConfig not implemented")
}
func (UnimplementedKubeManagerServiceServer) ApplyClusterConfig(context.Context, *ApplyClusterConfigRequest) (*OperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyClusterConfig not implemented")
}
func (UnimplementedKubeManagerServiceServer) GetClusterOperations(context.Context, *ClusterIDRequest) (*ClusterOperationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterOperations not implemented")
}
func (UnimplementedKubeManagerServiceServer) ListClusterUsers(context.Context, *ClusterIDRequest) (*ClusterUsersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListClusterUsers not implemented")
}
func (UnimplementedKubeManagerServiceServer) AddClusterUser(context.Context, *AddClusterUserRequest) (*OperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddClusterUser not implemented")
}
func (UnimplementedKubeManagerServiceServer) UpgradeCluster(context.Context, *UpgradeClusterRequest) (*OperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpgradeCluster not implemented")
}
func (UnimplementedKubeManagerServiceServer) GetNodeHealth(context.Context, *NodeHealthRequest) (*NodeHealthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNodeHealth not implemented")
}
func (UnimplementedKubeManagerServiceServer) mustEmbedUnimplementedKubeManagerServiceServer() {}
func (UnimplementedKubeManagerServiceServer) testEmbeddedByValue()                            {}

// UnsafeKubeManagerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KubeManagerServiceServer will
// result in compilation errors.
type UnsafeKubeManagerServiceServer interface {
	mustEmbedUnimplementedKubeManagerServiceServer()
}

func RegisterKubeManagerServiceServer(s grpc.ServiceRegistrar, srv KubeManagerServiceServer) {
	// If the following call pancis, it indicates UnimplementedKubeManagerServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&KubeManagerService_ServiceDesc, srv)
}

func _KubeManagerService_CreateCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeManagerServiceServer).CreateCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeManagerService_CreateCluster_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeManagerServiceServer).CreateCluster(ctx, req.(*CreateClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KubeManagerService_DeployApp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeployAppRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeManagerServiceServer).DeployApp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeManagerService_DeployApp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeManagerServiceServer).DeployApp(ctx, req.(*DeployAppRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KubeManagerService_ScaleCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScaleClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeManagerServiceServer).ScaleCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeManagerService_ScaleCluster_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeManagerServiceServer).ScaleCluster(ctx, req.(*ScaleClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KubeManagerService_DeleteCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClusterIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeManagerServiceServer).DeleteCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeManagerService_DeleteCluster_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeManagerServiceServer).DeleteCluster(ctx, req.(*ClusterIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KubeManagerService_GetClusterStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClusterIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeManagerServiceServer).GetClusterStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeManagerService_GetClusterStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeManagerServiceServer).GetClusterStatus(ctx, req.(*ClusterIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KubeManagerService_ListClustersByTenant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeManagerServiceServer).ListClustersByTenant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeManagerService_ListClustersByTenant_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeManagerServiceServer).ListClustersByTenant(ctx, req.(*TenantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KubeManagerService_GetClusterLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClusterIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeManagerServiceServer).GetClusterLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeManagerService_GetClusterLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeManagerServiceServer).GetClusterLogs(ctx, req.(*ClusterIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KubeManagerService_RestartComponent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RestartComponentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeManagerServiceServer).RestartComponent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeManagerService_RestartComponent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeManagerServiceServer).RestartComponent(ctx, req.(*RestartComponentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KubeManagerService_ExportClusterConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClusterIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeManagerServiceServer).ExportClusterConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeManagerService_ExportClusterConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeManagerServiceServer).ExportClusterConfig(ctx, req.(*ClusterIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KubeManagerService_ApplyClusterConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyClusterConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeManagerServiceServer).ApplyClusterConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeManagerService_ApplyClusterConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeManagerServiceServer).ApplyClusterConfig(ctx, req.(*ApplyClusterConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KubeManagerService_GetClusterOperations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClusterIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeManagerServiceServer).GetClusterOperations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeManagerService_GetClusterOperations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeManagerServiceServer).GetClusterOperations(ctx, req.(*ClusterIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KubeManagerService_ListClusterUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClusterIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeManagerServiceServer).ListClusterUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeManagerService_ListClusterUsers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeManagerServiceServer).ListClusterUsers(ctx, req.(*ClusterIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KubeManagerService_AddClusterUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddClusterUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeManagerServiceServer).AddClusterUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeManagerService_AddClusterUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeManagerServiceServer).AddClusterUser(ctx, req.(*AddClusterUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KubeManagerService_UpgradeCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpgradeClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeManagerServiceServer).UpgradeCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeManagerService_UpgradeCluster_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeManagerServiceServer).UpgradeCluster(ctx, req.(*UpgradeClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KubeManagerService_GetNodeHealth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeHealthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubeManagerServiceServer).GetNodeHealth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KubeManagerService_GetNodeHealth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubeManagerServiceServer).GetNodeHealth(ctx, req.(*NodeHealthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// KubeManagerService_ServiceDesc is the grpc.ServiceDesc for KubeManagerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var KubeManagerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "kubemanager.KubeManagerService",
	HandlerType: (*KubeManagerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCluster",
			Handler:    _KubeManagerService_CreateCluster_Handler,
		},
		{
			MethodName: "DeployApp",
			Handler:    _KubeManagerService_DeployApp_Handler,
		},
		{
			MethodName: "ScaleCluster",
			Handler:    _KubeManagerService_ScaleCluster_Handler,
		},
		{
			MethodName: "DeleteCluster",
			Handler:    _KubeManagerService_DeleteCluster_Handler,
		},
		{
			MethodName: "GetClusterStatus",
			Handler:    _KubeManagerService_GetClusterStatus_Handler,
		},
		{
			MethodName: "ListClustersByTenant",
			Handler:    _KubeManagerService_ListClustersByTenant_Handler,
		},
		{
			MethodName: "GetClusterLogs",
			Handler:    _KubeManagerService_GetClusterLogs_Handler,
		},
		{
			MethodName: "RestartComponent",
			Handler:    _KubeManagerService_RestartComponent_Handler,
		},
		{
			MethodName: "ExportClusterConfig",
			Handler:    _KubeManagerService_ExportClusterConfig_Handler,
		},
		{
			MethodName: "ApplyClusterConfig",
			Handler:    _KubeManagerService_ApplyClusterConfig_Handler,
		},
		{
			MethodName: "GetClusterOperations",
			Handler:    _KubeManagerService_GetClusterOperations_Handler,
		},
		{
			MethodName: "ListClusterUsers",
			Handler:    _KubeManagerService_ListClusterUsers_Handler,
		},
		{
			MethodName: "AddClusterUser",
			Handler:    _KubeManagerService_AddClusterUser_Handler,
		},
		{
			MethodName: "UpgradeCluster",
			Handler:    _KubeManagerService_UpgradeCluster_Handler,
		},
		{
			MethodName: "GetNodeHealth",
			Handler:    _KubeManagerService_GetNodeHealth_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "kubemanager.proto",
}
